{
    "id": "u2-t4-boolean-search",
    "title": "Boolean Search Operations",
    "unitId": "unit-2",
    "slides": [
        {
            "slideNumber": 1,
            "type": "title",
            "title": "Boolean Search Operations",
            "subtitle": "Processing AND, OR, NOT Queries",
            "content": {
                "text": "Boolean search operations combine terms using logical operators (AND, OR, NOT) to find documents matching complex criteria. They're implemented by merging sorted postings lists.",
                "hook": "Find documents about 'cats' AND 'dogs' but NOT 'allergies' - all in milliseconds."
            }
        },
        {
            "slideNumber": 2,
            "type": "standard",
            "title": "Boolean Query Model",
            "content": {
                "definition": "A query model where documents either match or don't match - no ranking, just binary relevance.",
                "text": "Boolean queries use set operations on postings lists: AND (intersection), OR (union), NOT (difference).",
                "outcomes": [
                    "Precise control over query logic",
                    "No ranking - all results equally relevant",
                    "Fast processing via list merging",
                    "Used in legal, patent, medical search"
                ]
            }
        },
        {
            "slideNumber": 3,
            "type": "standard",
            "title": "AND Operation (Intersection)",
            "content": {
                "text": "Find documents containing ALL query terms:",
                "outcomes": [
                    "Merge two sorted postings lists",
                    "Keep only document IDs in both lists",
                    "Linear time: O(n + m) where n, m are list lengths",
                    "Process shortest list first for efficiency",
                    "Example: 'cat' AND 'dog' → docs with both terms"
                ]
            }
        },
        {
            "slideNumber": 4,
            "type": "standard",
            "title": "OR Operation (Union)",
            "content": {
                "text": "Find documents containing ANY query term:",
                "outcomes": [
                    "Merge two sorted postings lists",
                    "Keep all document IDs from both lists",
                    "Linear time: O(n + m)",
                    "Remove duplicates during merge",
                    "Example: 'cat' OR 'dog' → docs with either term"
                ]
            }
        },
        {
            "slideNumber": 5,
            "type": "standard",
            "title": "NOT Operation (Difference)",
            "content": {
                "text": "Exclude documents containing a term:",
                "outcomes": [
                    "Remove document IDs from first list",
                    "Must be combined with positive terms",
                    "NOT alone is meaningless (all docs without term?)",
                    "Example: 'cat' NOT 'dog' → docs with cat but not dog",
                    "Expensive if NOT term is rare"
                ]
            }
        },
        {
            "slideNumber": 6,
            "type": "standard",
            "title": "Query Optimization",
            "content": {
                "text": "Making Boolean queries faster:",
                "outcomes": [
                    "Process terms in order of increasing frequency",
                    "Shortest postings list first",
                    "Skip pointers for faster merging",
                    "Early termination when possible",
                    "Rewrite queries for efficiency"
                ]
            }
        },
        {
            "slideNumber": 7,
            "type": "python_demo",
            "title": "Python Demo: Boolean Query Processing",
            "content": {
                "code": "def merge_and(list1, list2):\n    \"\"\"Merge two sorted lists with AND (intersection)\"\"\"\n    result = []\n    i, j = 0, 0\n    \n    while i < len(list1) and j < len(list2):\n        if list1[i] == list2[j]:\n            result.append(list1[i])\n            i += 1\n            j += 1\n        elif list1[i] < list2[j]:\n            i += 1\n        else:\n            j += 1\n    \n    return result\n\ndef merge_or(list1, list2):\n    \"\"\"Merge two sorted lists with OR (union)\"\"\"\n    result = []\n    i, j = 0, 0\n    \n    while i < len(list1) and j < len(list2):\n        if list1[i] == list2[j]:\n            result.append(list1[i])\n            i += 1\n            j += 1\n        elif list1[i] < list2[j]:\n            result.append(list1[i])\n            i += 1\n        else:\n            result.append(list2[j])\n            j += 1\n    \n    # Add remaining elements\n    result.extend(list1[i:])\n    result.extend(list2[j:])\n    \n    return result\n\ndef merge_not(list1, list2):\n    \"\"\"Remove list2 elements from list1 (difference)\"\"\"\n    result = []\n    i, j = 0, 0\n    \n    while i < len(list1):\n        if j >= len(list2) or list1[i] < list2[j]:\n            result.append(list1[i])\n            i += 1\n        elif list1[i] == list2[j]:\n            i += 1\n            j += 1\n        else:\n            j += 1\n    \n    return result\n\n# Example index\nindex = {\n    'cat': [1, 2, 4, 7],\n    'dog': [2, 3, 4, 5],\n    'bird': [1, 3, 6, 7]\n}\n\nprint(\"Index:\")\nfor term, docs in index.items():\n    print(f\"  {term}: {docs}\")\n\nprint(\"\\nQueries:\")\nprint(f\"cat AND dog: {merge_and(index['cat'], index['dog'])}\")\nprint(f\"cat OR dog: {merge_or(index['cat'], index['dog'])}\")\nprint(f\"cat NOT dog: {merge_not(index['cat'], index['dog'])}\")\nprint(f\"(cat OR bird) AND dog: {merge_and(merge_or(index['cat'], index['bird']), index['dog'])}\")",
                "input": "Index with 3 terms, 7 documents",
                "output": "Index:\n  cat: [1, 2, 4, 7]\n  dog: [2, 3, 4, 5]\n  bird: [1, 3, 6, 7]\n\nQueries:\ncat AND dog: [2, 4]\ncat OR dog: [1, 2, 3, 4, 5, 7]\ncat NOT dog: [1, 7]\n(cat OR bird) AND dog: [2, 3]",
                "interpretation": "Boolean operations merge sorted postings lists efficiently. AND finds docs in both lists [2, 4]. OR finds docs in either list [1, 2, 3, 4, 5, 7]. NOT removes dog docs from cat [1, 7]. Complex queries combine operations: (cat OR bird) gives [1, 2, 3, 4, 6, 7], then AND with dog gives [2, 3]."
            }
        },
        {
            "slideNumber": 8,
            "type": "activity",
            "title": "Activity: Manual List Merging",
            "content": {
                "activity": "Process Boolean Queries",
                "description": "Given:\nterm1: [2, 5, 10, 22, 31]\nterm2: [5, 12, 22, 45]\n\nCompute:\n1. term1 AND term2 = ?\n2. term1 OR term2 = ?\n3. term1 NOT term2 = ?\n\nHow many comparisons for each?"
            }
        },
        {
            "slideNumber": 9,
            "type": "quiz",
            "title": "Topic Quiz",
            "questions": [
                "Why must postings lists be sorted for efficient Boolean operations?",
                "What is the time complexity of merging two postings lists?",
                "Why is 'NOT' alone not a valid query?",
                "How do you optimize a query with multiple AND operations?"
            ],
            "answers": [
                "Sorted lists enable linear-time merging. We can walk through both lists once, comparing elements. Unsorted lists would require nested loops (quadratic time) or sorting first.",
                "O(n + m) where n and m are the lengths of the two lists. We scan each list once, comparing and merging elements.",
                "NOT alone would return all documents NOT containing a term, which is usually the entire collection minus a few docs. It's meaningless without positive terms to start from.",
                "Process terms in order of increasing document frequency (shortest postings list first). This minimizes the size of intermediate results and reduces total comparisons."
            ]
        },
        {
            "slideNumber": 10,
            "type": "research_perspective",
            "title": "Research Perspective: Skip Pointers",
            "content": {
                "researchQuestions": [
                    {
                        "question": "Can we make list merging faster than O(n + m)?",
                        "answer": "Skip pointers add shortcuts in postings lists, allowing jumps over irrelevant sections. For AND operations with very different list sizes, skip pointers can reduce comparisons significantly. However, they add space overhead and complexity."
                    },
                    {
                        "question": "How do modern systems handle complex Boolean queries?",
                        "answer": "Query optimization rewrites queries for efficiency: 1) Push NOT operations to the end, 2) Process shortest lists first, 3) Use bloom filters for quick negative checks, 4) Parallel processing for independent sub-queries."
                    }
                ],
                "mathematicalModeling": {
                    "problemStatement": "Modeling optimal query execution order.",
                    "derivation": [
                        {
                            "step": "Define cost of AND operation as sum of list lengths.",
                            "equation": "Cost(A \\cap B) = |A| + |B|",
                            "interpretation": "We scan both lists once, so cost is linear in total size."
                        },
                        {
                            "step": "Model optimal ordering for multi-term AND.",
                            "equation": "Order: |A_1| \\leq |A_2| \\leq ... \\leq |A_n|",
                            "interpretation": "Process shortest list first to minimize intermediate result sizes."
                        }
                    ],
                    "conclusion": "Boolean search provides precise control through set operations. Optimization focuses on minimizing list scans through smart ordering and skip pointers."
                }
            }
        },
        {
            "slideNumber": 11,
            "type": "summary",
            "title": "Key Takeaways",
            "content": {
                "text": "Boolean search uses set operations (AND, OR, NOT) on sorted postings lists. Efficient merging and query optimization are key to fast processing.",
                "nextTopic": "Index Compression",
                "preparation": "Learn about gap encoding and variable-byte codes for compressing postings lists."
            }
        }
    ]
}
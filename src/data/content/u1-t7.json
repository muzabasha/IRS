{
    "id": "u1-t7",
    "title": "Structured Text Retrieval",
    "unitId": "unit-1",
    "slides": [
        {
            "slideNumber": 1,
            "type": "title",
            "title": "Structured Text Retrieval",
            "subtitle": "Combining Content and Structure",
            "content": {
                "text": "Retrieval isn't just about 'what' is said, but 'where' it is said. Finding a keyword in a <Title> tag is more valuable than in a <footer>.",
                "hook": "Query: 'Find books with *Hamlet* in the Title and *Ghost* in the Chapter 1'."
            }
        },
        {
            "slideNumber": 2,
            "type": "standard",
            "title": "The Need for Structure",
            "content": {
                "problem": "Flat Bag-of-Words loses context.",
                "text": "Documents often have hierarchical structure (Books > Chapters > Sections). Standard IR flattens this. Structured IR exploits it for more precise queries."
            }
        },
        {
            "slideNumber": 3,
            "type": "diagram",
            "title": "Document Structural Hierarchy",
            "content": {
                "description": "Visualizing a document as a tree of nodes (DOM).",
                "steps": [
                    "Root (Document Body)",
                    "Container Nodes (Chapters/Sections)",
                    "Semantic Tags (Title/Author)",
                    "Leaf Nodes (Raw Text Content)"
                ]
            }
        },
        {
            "slideNumber": 4,
            "type": "list",
            "title": "Models for Structured Text",
            "items": [
                "Non-Overlapping Lists: Dividing text into distinct regions (e.g., Pages).",
                "Proximal Nodes: Finding nodes that contain specific terms within a certain distance.",
                "XML Information Retrieval: Querying against schemas (XPath, XQuery)."
            ]
        },
        {
            "slideNumber": 5,
            "type": "standard",
            "title": "Proximal Nodes Model",
            "content": {
                "definition": "A hierarchical indexing system where each node in the document tree can be retrieved independently.",
                "text": "Allows queries like `[Chapter] containing ('analysis' AND 'design')`."
            }
        },
        {
            "slideNumber": 6,
            "type": "illustration",
            "title": "Containment Logic Workflow",
            "content": {
                "description": "How structural operators determine a match.",
                "steps": [
                    "Evaluate Content Term (e.g. 'King')",
                    "Determine Node Scope (e.g. <Title>)",
                    "Check Containment Constraint",
                    "Return Content-in-Context Match"
                ]
            }
        },
        {
            "slideNumber": 7,
            "type": "standard",
            "title": "Structuring the Index",
            "content": {
                "text": "We index structure alongside text. The inverted index includes position info: `(DocID, StartPos, EndPos, Depth)`.",
                "outcomes": [
                    "Allows 'Near' operators.",
                    "Allows specific field weighting (Title=1.0, Body=0.5)."
                ]
            },
            "formula": {
                "equation": "C(node, term) \\iff [S_{term}, E_{term}] \\subseteq [S_{node}, E_{node}]",
                "description": "Structured retrieval using the Interval Model defines a match (C) as a containment relationship where the position interval of a term falls within the boundaries [S, E] of a specific logical node.",
                "terms": [
                    {
                        "symbol": "S_{node}, E_{node}",
                        "meaning": "The start and end word-positions of a structural element (e.g. <abstract>)"
                    },
                    {
                        "symbol": "S_{term}, E_{term}",
                        "meaning": "The position(s) of the search term in the document"
                    },
                    {
                        "symbol": "\\subseteq",
                        "meaning": "Containment operator (All term positions must be inside node boundaries)"
                    }
                ],
                "calculation": {
                    "exampleTitle": "Containment Logic check",
                    "description": "Determining if 'search' appears in the document 'Abstract'.",
                    "steps": [
                        {
                            "label": "Define Node Scope",
                            "formula": "\\text{Abstract} = [50, 150]",
                            "note": "The abstract tag covers words 50 through 150."
                        },
                        {
                            "label": "Locate Term",
                            "formula": "\\text{Pos}(search) = 75",
                            "note": "Term 'search' is the 75th word."
                        },
                        {
                            "label": "Evaluate Interval",
                            "formula": "75 \\in [50, 150] \\Rightarrow \\text{True}",
                            "note": "Term falls within the defined boundaries."
                        },
                        {
                            "label": "Final Result",
                            "formula": "\\text{Result} = Match",
                            "note": "The document satisfies the structural constraint."
                        }
                    ],
                    "input": "Node:[50, 150], Term:75",
                    "output": "Match = YES"
                }
            }
        },
        {
            "slideNumber": 8,
            "type": "activity",
            "title": "Activity: XPath Querying",
            "content": {
                "activity": "Structure Hunting",
                "description": "Given an XML snippets of a bookstore. Write a pseudo-XPath query to find 'Prices of books by Author X'."
            }
        },
        {
            "slideNumber": 9,
            "type": "project",
            "title": "Mini-Project: HTML Parser",
            "content": {
                "idea": "Title Scraper",
                "input": "A raw HTML string.",
                "process": "Parse the string to identify content inside <h1> and <title> tags. Treat these as 'High Importance'.",
                "output": "A weighted index where title words count double."
            }
        },
        {
            "slideNumber": 10,
            "type": "quiz",
            "title": "Quiz",
            "questions": [
                "What is the difference between specific field retrieval and general text retrieval?",
                "How does the Proximal Nodes model define a 'match'?",
                "Why is XML retrieval more complex than standard web search?",
                "Give an example of a structural constraint in a query."
            ],
            "answers": [
                "General retrieval searches the entire document as a flat bag of words, while specific field retrieval targets constrained sections (e.g., Title, Abstract) for higher precision.",
                "A match occurs when the query terms appear within a specific hierarchical instance (node) of the document tree, often satisfying distance or containment constraints.",
                "Because XML retrieval must return specific *elements* (granularity) rather than just full documents, and queries often involve complex path logic (parent/child relationships).",
                "`Title contains \"Hamlet\" AND Section contains \"Ghost\"` or `Author=\"Shakespeare\"`."
            ]
        },
        {
            "slideNumber": 11,
            "type": "python_demo",
            "title": "Python Demo: Fuzzy Set Matching",
            "content": {
                "code": "def fuzzy_score(membership_query, membership_doc):\n    # Fuzzy AND is MIN operator\n    return min(membership_query, membership_doc)\n\n# User wants 'highly relevant' (degree 0.9)\n# Doc has 'partial match' (degree 0.4)\nmatch = fuzzy_score(0.9, 0.4)\nprint(f\"Fuzzy Match Degree: {match}\")",
                "input": "QueryDegree: 0.9, DocDegree: 0.4",
                "output": "Fuzzy Match Degree: 0.4",
                "interpretation": "Fuzzy retrieval moves beyond binary (0 or 1) matches.\nIt calculates a 'degree of membership'.\nIn this example, the resulting match is limited by the document's partial relevance (0.4)."
            }
        },
        {
            "slideNumber": 12,
            "type": "research_perspective",
            "title": "Research Perspective: Granularity & Structural Reasoning",
            "content": {
                "researchQuestions": [
                    {
                        "question": "The Focused Retrieval Problem: How can a system determine the optimal 'Size' (Granularity) of a search result in structured text?",
                        "answer": "When searching a large XML book, returning the whole book is too broad, but returning a single sentence is too narrow. Research in Focused Retrieval (INEX) focuses on 'Relevant Element Extraction'. This uses mathematical propagation techniques where the relevance score of a leaf node is 'bubbled up' to parent nodes, and the node with the highest 'Information Density' is selected as the result unit."
                    },
                    {
                        "question": "Structural Context: To what extent does the tree-distance between terms impact the semantic interpretation of a query?",
                        "answer": "In structured IR, terms 'A' and 'B' in the same section are more related than if they are in different chapters. Research models this using 'Tree Edit Distance' and 'LCA (Lowest Common Ancestor)' distance. The retrieval score is attenuated by a function of the path length between terms in the document hierarchy, ensuring that structural proximity mirrors semantic proximity."
                    }
                ],
                "mathematicalModeling": {
                    "problemStatement": "Modeling the relevance of a structural node based on the weighting and containment of terms.",
                    "derivation": [
                        {
                            "step": "Define a Document as a Tree T = (V, E) and a query as a set of content-structure constraints.",
                            "equation": "Score(v) = \\sum_{t \\in q} w(t, v) \\cdot \\Phi(v, query\\_tag)",
                            "interpretation": "The score of node v depends on the content weight and a structural binary function that checks if v matches the requested tag (e.g., v=Section)."
                        },
                        {
                            "step": "Model the 'Parent-Child' relevance propagation using an attenuation factor.",
                            "equation": "Weight(parent) = \\sum_{child \\in children(parent)} \\gamma \\cdot Weight(child)",
                            "interpretation": "Relevance scores are aggregated up the tree, but attenuated by \\gamma (0 < \\gamma < 1) to account for data dilution."
                        },
                        {
                            "step": "Solve for the 'Optimal Retrieval Unit' (ORU) using the Information Gain per character.",
                            "equation": "ORU = \\arg \\max_{v} \\frac{Score(v)}{Length(v)}",
                            "interpretation": "The system chooses the node that provides the highest concentration of relevant keywords, avoiding long nodes with scattered matches."
                        }
                    ],
                    "conclusion": "Structured IR demonstrates that Information Retrieval is a 2-dimensional problem: finding the right 'What' (content) in the right 'Where' (structure), proving that hierarchies define the boundaries of information utility."
                }
            }
        },
        {
            "slideNumber": 13,
            "type": "summary",
            "title": "Topic Wrap-up",
            "content": {
                "linkage": "We can now find text in structure. But what if we 'browse' instead of search?",
                "nextTopic": "Browsing Models",
                "preparation": "Think about directory structures and hyperlinks."
            }
        }
    ]
}
{
    "id": "u2-t6",
    "title": "Index Compression",
    "unitId": "unit-2",
    "slides": [
        {
            "slideNumber": 1,
            "title": "Index Compression",
            "type": "title",
            "subtitle": "Optimizing Space and Speed",
            "content": {
                "text": "A full inverted index for the web would be multi-terabyte. We compress the dictionary (to fit in RAM - Random Access Memory) and the postings (to save disk I/O - Input/Output).",
                "hook": "Compression doesn't just save space; it often makes search faster by reducing I/O (Input/Output)."
            }
        },
        {
            "slideNumber": 2,
            "type": "standard",
            "title": "Dictionary Compression",
            "content": {
                "text": "The dictionary contains terms and pointers. We can compress it using techniques like:",
                "outcomes": [
                    "Dictionary-as-a-string: Removing the fixed-length overhead for terms.",
                    "Front Coding: Storing shared prefixes only (e.g., 'automata', 'automate', 'automatic').",
                    "Blocked Storage: Grouping terms to save pointer space."
                ]
            }
        },
        {
            "slideNumber": 3,
            "type": "illustration",
            "title": "Front Coding Example",
            "content": {
                "caption": "Storing 'auto-mata', '-mate', '-matic' instead of full words.",
                "description": "This leverages the alphabetical sorting of the dictionary."
            }
        },
        {
            "slideNumber": 4,
            "type": "standard",
            "title": "Postings Compression",
            "content": {
                "text": "The biggest part of the index. Since DocIDs are sorted, we store the Gaps (D-gaps) between them instead of the raw IDs.",
                "hook": "Postings: [100, 105, 110] -> [100, 5, 5]. Smaller numbers = fewer bits."
            }
        },
        {
            "slideNumber": 5,
            "type": "grid",
            "title": "Variable Byte Encoding (V-Byte)",
            "items": [
                "Small numbers use 1 byte.",
                "Large numbers use more.",
                "Uses 7 bits for data and 1 bit as a 'continuation' flag.",
                "Extremely fast to decode."
            ],
            "formula": {
                "equation": "\\text{Byte}(n) = [C, b_6, b_5, b_4, b_3, b_2, b_1, b_0]",
                "description": "Variable Byte encoding uses a series of bytes to represent an integer, where the highest-order bit (C) is a continuation bit (0 = more bytes follow, 1 = last byte).",
                "terms": [
                    {
                        "symbol": "n",
                        "meaning": "The positive integer (gap) to be encoded"
                    },
                    {
                        "symbol": "C",
                        "meaning": "Continuation bit (MSB)"
                    },
                    {
                        "symbol": "b_i",
                        "meaning": "Data bits from the binary representation of the gap"
                    }
                ],
                "calculation": {
                    "exampleTitle": "V-Byte Encoding process",
                    "description": "Encoding the number 130 into Variable Byte format.",
                    "steps": [
                        {
                            "label": "Binary Conversion",
                            "formula": "130_{10} = 10000010_2",
                            "note": "130 is slightly larger than the 7-bit limit (127)."
                        },
                        {
                            "label": "Split into 7-bit Chunks",
                            "formula": "Chunk 2: 0000001, Chunk 1: 0000010",
                            "note": "We take the lowest 7 bits first."
                        },
                        {
                            "label": "Assign Continuation Bits",
                            "formula": "Byte 1: [0, 0000001], Byte 2: [1, 0000010]",
                            "note": "First byte has C=0 (more follows), second has C=1 (end)."
                        },
                        {
                            "label": "Final V-Byte",
                            "formula": "[00000001, 10000010] = [1, 130]",
                            "note": "Value is reconstructed as (1 * 128) + 2 = 130."
                        }
                    ],
                    "input": "n:130",
                    "output": "Bytes: [0x01, 0x82]"
                }
            }
        },
        {
            "slideNumber": 6,
            "type": "standard",
            "title": "Gamma Encoding",
            "content": {
                "definition": "A bit-level compression scheme for very small gaps. It encodes a gap as (length in unary, value in binary).",
                "text": "Optimal for distributions that follow Zipf's Law (where many gaps are 1 or 2)."
            }
        },
        {
            "slideNumber": 7,
            "type": "activity",
            "title": "Activity: Gap Coding",
            "content": {
                "activity": "Calculate the Gaps",
                "description": "Original IDs: [15, 22, 23, 40, 41, 42, 60]. Write down the D-gaps. Notice how many '1' gaps occur."
            }
        },
        {
            "slideNumber": 8,
            "type": "project",
            "title": "Mini-Project: V-Byte",
            "content": {
                "idea": "Bit Manipulator",
                "input": "Number 130.",
                "process": "Convert 130 into 2-byte V-byte (Hint: 130 > 127).",
                "output": "The two hex values for the bytes."
            }
        },
        {
            "slideNumber": 9,
            "type": "quiz",
            "title": "Quiz",
            "questions": [
                "Why is compression beneficial for search speed?",
                "What is 'Front Coding'?",
                "Define a 'D-gap'.",
                "How many bits are used for data in a standard Variable Byte?"
            ]
        },
        {
            "slideNumber": 10,
            "type": "python_demo",
            "title": "Python Demo: Binary Independence Model",
            "content": {
                "code": "def calculate_rsv(p_rel, u_nonrel):\n    # Simplified Retrieval Status Value\n    import math\n    rsv = 0\n    for p, u in zip(p_rel, u_nonrel):\n        rsv += math.log( (p * (1-u)) / (u * (1-p)) )\n    return round(rsv, 3)\n\n# Term 1: p=0.8 (rel), u=0.1 (non-rel)\n# Term 2: p=0.7 (rel), u=0.2 (non-rel)\nstatus = calculate_rsv([0.8, 0.7], [0.1, 0.2])\nprint(f\"RSV Score: {status}\")",
                "input": "P:[0.8, 0.7], U:[0.1, 0.2]",
                "output": "RSV Score: 3.296",
                "interpretation": "BIM calculates the log-odds of a document being relevant.\nIf a term appears frequently in relevant docs (High P) and rarely in non-relevant ones (Low U), the score increases.\nThis is the core of probabilistic retrieval theories."
            }
        },
        {
            "slideNumber": 11,
            "type": "summary",
            "title": "Topic Wrap-up",
            "content": {
                "linkage": "We have covered how to build, clean, and compress the engine. Next, we move to the User Interface.",
                "nextTopic": "Unit 3: User Interfaces",
                "preparation": "Think about how we present these compressed results to a human."
            }
        }
    ]
}